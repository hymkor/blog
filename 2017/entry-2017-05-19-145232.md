```header
Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2017/05/19/145232
Rem: App-Edited: 2017-05-19T15:31:20+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/10328749687248816756
Rem: Published: 2017-05-19T14:52:32+09:00
Category: Go Windows
Updated: 2017-05-19T14:52:32+09:00
Title: Go for Windows で子プロセスに二重引用符を引数でそのまま渡したい時
```
問題の症状
=========

親プロセスのソース：

```
// exec1.go
package main

import (
	"os"
	"os/exec"
)

func main() {
	c := exec.Command("foo", `"<BAR>"`)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	c.Stdin = os.Stdin
	c.Run()
}
```

子プロセスのソース（バッチファイル）：

```
@rem foo.cmd
@echo %0 %*
@exit /b 0
```

実行すると

```console
$ go run exec1.go
foo \"<BAR>\"
```

二重引用符の前にバックスラッシュがついてしまう。

解決方法
=======

バックスラッシュが付かないようにするには、Go言語標準の`exec.Cmd.Args[]`を Windows 形式の引数形式に展開する処理をパスして、自前で直接指定すればよい。

```
//exec2.go
package main

import (
	"os"
	"os/exec"
	"syscall"
)

func main() {
	c := exec.Command("foo")
	c.SysProcAttr = &syscall.SysProcAttr{CmdLine: `foo "<BAR>"`}
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	c.Stdin = os.Stdin
	c.Run()
}
```

```console
$ go run exec2.go
foo "<BAR>"
```

なぜ、こんなことをする必要があるのか
================================

FIND.EXE や CMD.EXE は、引数につけられた二重引用符の有無で、その引数がどういうものか判別しています。このため、Goのプログラムから FIND.EXE が意図どおりに呼べないという問題が発生していました。

* [`dir | find "<DIR>" · Issue #218 · zetamatta/nyagos`](https://github.com/zetamatta/nyagos/issues/218)

こういう仕様って、どこに書いてあったの？
====================================

[ここ](https://github.com/golang/go/blob/master/src/syscall/exec_windows.go#L267)
