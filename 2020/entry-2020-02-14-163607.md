Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2020/02/14/163607
Rem: App-Edited: 2023-04-28T22:40:16+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/26006613511939210
Rem: Published: 2020-02-25T12:48:19+09:00
Category: VB.net
Updated: 2020-02-14T16:36:07+09:00
Title:  バックグラウンドワーカーからダイアログのデータを更新する
---
（2020.02.25 追記あり）

通常は BackgroundWorker からダイアログのコントロールを操作することはできない。だが、Delegate を経由すれば、可能になる。

```vb
Public Class Form1
    '*** UIスレッドで実行される関数 ***
    Private Sub AddRow(color1 As Color, objs As Object())
        Dim row1 As New DataGridViewRow
        row1.CreateCells(Me.DataGrid_Sheet)
        For i As Integer = LBound(objs) To UBound(objs)
            row1.Cells(i).Value = objs(i)
        Next
        row1.DefaultCellStyle.BackColor = color1
        row1.Resizable = DataGridViewTriState.False
        Me.DataGrid_Sheet.Rows.Add(row1)
    End Sub

    '*** UIスレッドへ、更新データを送る Delegate の宣言
    Delegate Sub AddRowDelegate(color1 As Color, objs As Object())
    Private AddRowDelegate1 As New AddRowDelegate(AddressOf AddRow)

   '*** バックグラウンドワーカー
    Private Sub BackgroundWorker1_DoWork(sender As Object, e As System.ComponentModel.DoWorkEventArgs) Handles BackgroundWorker1.DoWork
   '            : 中略
                Me.Invoke(AddRowDelegate1,
                    color,
                    New Object() { 
                        ' セルデータ,
                    }  )
  '            : 中略
    End Sub
```

ただし、あまりにも更新のスピードが多いと、U/I スレッドがそれへの応答でいっぱいいっぱいになって応答がなくなってしまい、BackgroundWorker の意味がなくなってしまう。

そのような場合、結局、タイマ割り込みで休み休みやった方が安全のようだ。（このあたりは推測にすぎないが…）

（2020.02.25 追記）

本記事では、当初、次のように書いていた。

```vb
Me.AddRowDelegate1.Invoke(
    color,
    New Object() { 
            ' セルデータ,
            }  )
```

だが、[Windowsフォームで別スレッドからコントロールを操作するには？：.NET TIPS - ＠IT](https://www.atmarkit.co.jp/ait/articles/0506/17/news111.html)によると、コントロールのメソッドとして呼ばないと、意味がないようだ（そりゃそうだ）

```vb
Me.Invoke(
    AddRowDelegate1,
    color,
    New Object() { 
           ' セルデータ,
    }  )
```

また、Invoke はメインスレッドをブロックするが、BeginInvoke だと待機状態になったタイミングで実行するとあるので、BeginInvokeを使えば U/I スレッドがいっぱいいっぱいになることは避けられるかもしれない