Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2020/12/21/190127
Rem: App-Edited: 2020-12-21T21:18:58+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/26006613668173450
Rem: Published: 2020-12-21T19:01:27+09:00
Category: go
Updated: 2020-12-21T19:01:27+09:00
Title:  ビルドタグは import 先にまで派生する
---
まぁ、当たり前の話ではあるんだけど、github.com/zetamatta/go-windows-dbg を改造するにあたって大丈夫か？とちょっと不安になったので、念のため検証。

サブパッケージ(bar)は release タグの有無で挙動が変わる。タグを指定するのはメインパッケージ(main=foo)となる。

#### github.com/zetamatta/bar/main.go

サブパッケージ。タグ release が設定されていない時だけ有効

```go
// +build !release

package bar

func Run() {
	println("not release")
}
```

#### github.com/zetamatta/bar/main_release.go

サブパッケージ。タグ release が設定されている時だけ有効

```go
// +build release

package bar

func Run() {
	println("release")
}
```

#### github.com/zetamatta/foo/main.go

メインパッケージ。ここのビルド時にタグを指定する

```go
package main

import (
	"github.com/zetamatta/bar"
)

func main(){
	bar.Run()
}
```

#### 実験

```
<~/go/src/github.com/zetamatta/foo>
$ go build && foo
not release
<:~/go/src/github.com/zetamatta/foo>
$ go build -tags=release && foo
release
```

よしよし

複数のビルドタグによる条件ビルドの構文
------

* [build - Go 言語](http://xn--go-hh0g6u.com/pkg/go/build/)

によると

* AND はタグを `,` （カンマ）区切りでならべるか、次の行に +build 行を追加
* OR はタグを空白区切りでならべる
* 結合の強さは `,` ＞ 空白 ＞改行

（例）

* `// +build !ndebug,windows`  
→ `! defined(ndebug) && defined(windows)` に相当  

* `// +build !windows ndebug`  
→ `! defined(windows) || defined(ndebug)` に相当

なるほど！