Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2023/11/02/013149
Rem: App-Edited: 2024-01-21T12:50:16+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6801883189055341488
Rem: Published: 2023-11-02T01:41:21+09:00
Category: Rust
Updated: 2023-11-02T01:31:49+09:00
Title: Rust で panic なしに雑にエラーを扱いたいとき
---
Go だと、errors.New, fmt.Errorf で、簡単にエラーオブジェクトを作れる。

Rust のエラー処理のサンプルをいろいろ見てみたが、panic で終わらせるものが多いが、panic を使った時点で関数の汎用性がほとんどなくなってしまう。

エラーを返す場合、ほとんどの記事では自前のエラー型を作らせているが、手間がかかりすぎる。簡略化するクレートとしては、 anyhow 、thiserror などがよく紹介されているが[^1]、 errors.New , fmt.Errorf に比べると、それすら大仰すぎる。

[^1]: https://zenn.dev/hakoten/articles/8ae9dd0d3a2080

さらにずぼらなエラー処理を模索すると、無いこともないようで、次のような方法が見受けられた。

1. `Result<…,String>` のように文字列型をエラーにしてしまう  
2. `Result<…,Box<dyn std::error:Error>>` を使う

前者の場合、同じ関数内で `?` 演算子が使えなくなってしまうため、後者を取ると、

- 既存のエラーオブジェクトは、そのまま `?` で return 値にできる（同じ trait なので）
- errors.New, fmt.Errorf 的な簡易エラーは `return Err(Box::from("…"))` で作成

という形になる。これで、拙作の [sponge](https://github.com/hymkor/sponge-rs) のmain関数を書き直してみた。

```rust
fn mains() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = std::env::args().skip(1);
    let original = match args.next() {
        Some(original) => original,
        None => return Err(Box::from("filename is not specified")),
    };
    sponge(&original)?;
    Ok(())
}

fn main() {
    if let Err(err) = mains() {
        eprintln!("{}", err);
        std::process::exit(1);
    }
}
```

よしよし
