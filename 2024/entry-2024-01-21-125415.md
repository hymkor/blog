```header
Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2024/01/21/125415
Rem: App-Edited: 2024-01-21T12:54:15+09:00
Rem: Draft: yes
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/4207112889977652797
Rem: Published: 2023-10-17T20:38:11+09:00
Category: Go
Updated: 2023-04-03T20:23:23+09:00
Title: go-readline-ny：キーに機能を割り付ける
```
go-readliny-ny はキーに任意の関数を設定することができます。go-readline-ny の拡張として、go-multiline-ny を例に説明します。go-multiline-ny は複数行対応するためには、カーソルキーの上下や Enter キーの動作を変更する必要がありました。以下はその割り付けを行うコードです。

[github.com/hymkor/go-multiline-ny/main.go](https://github.com/hymkor/go-multiline-ny/blob/e753dc4c1a7bf4d1ea2c8f87e9adf622f41d2370/main.go#L14)

```go
type Editor struct {
        LineEditor readline.Editor

        Prompt func(w io.Writer, i int) (int, error)
        // Has unexported fields.
}
```

[github.com/hymkor/go-multiline-ny/main.go](https://github.com/hymkor/go-multiline-ny/blob/e753dc4c1a7bf4d1ea2c8f87e9adf622f41d2370/main.go#L185)

```go
func (m *Editor) init() {
    // :
    m.LineEditor.BindKeyClosure(readline.K_CTRL_N, m.down)
    // :
}
```

`(*readline.Editor) BindKeyClosure` はキーに関数を設定するメソッドです。第一引数はキーとして go-readline-ny のソース [constant.go](https://github.com/nyaosorg/go-readline-ny/blob/93064a4d6ecf7ecd74978f8d87aea6333dedf5f6/constants.go) に記載されている `K_` で始まる識別子で指定します。

第二引数はキーに設定する機能を `func(ctx context.Context, b *readline.Buffer) readline.Result` というパラメータの関数で与えます。その関数が呼ばれるとき、現在の編集内容が入っている構造体 readline.Buffer へのポインタが渡されます。

[github.com/nyaosorg/go-readline-ny/buffer.go](https://github.com/nyaosorg/go-readline-ny/blob/61b984c6759c67164c399dcf6bf066d2006db38c/buffer.go#L55)

```go
type Buffer struct {
        *Editor
        Buffer []Cell

        ViewStart int

        // Has unexported fields.
}
```

構造体 readline.Buffer 内の同名のフィールド Buffer は編集中の文字＋色情報セットを表すデータ readline.Cell のスライスです。

[github.com/nyaosorg/go-readline-ny/buffer.go](https://github.com/nyaosorg/go-readline-ny/blob/61b984c6759c67164c399dcf6bf066d2006db38c/buffer.go#L42)

```go
type Cell struct {
        Moji Moji

        // Has unexported fields.
}
```

Cell の色情報データは非公開フィールドになっており、編集行を再表示するときなどに自動的に更新・利用される作業領域です[^color]。一方、Moji の方は次のような interface になっています。

[^color]: 色を外部から指定するには前回説明を書いた Coloring を使います

[github.com/nyaosorg/go-readline-ny/moji.go](https://github.com/nyaosorg/go-readline-ny/blob/61b984c6759c67164c399dcf6bf066d2006db38c/moji.go#L50)

```go
type Moji interface {
        Width() WidthT // 文字の表示時の桁数を得る (WidthT は intにキャスト可能な整数型）
        WriteTo(io.Writer) (int64, error) // UTF8に変換して io.Writer に書き込む（strings.Builder 向け）
        PrintTo(io.Writer) // WriteToと似ているが、表示調整用のエスケープシーケンスが付与される
}
```

Moji はいわゆる Unicode のコードポイントと 1 vs 1 になっていません。Unicode には複数のコードポイントをつなげて１文字にする合字、直前のコードポイントの違うバリエーションを指定するセレクタをつなげた異体字などがあり、１コードポイントが人間が認識する１文字となっていません。Moji はそれらをひっくるめた人間から見た「１文字」を扱う型となっています。

-----

キーにバインドする関数に話を戻します。この戻り値 readline.Result は次の３種類の値をとります。

[github.com/nyaosorg/go-readline-ny/readline.go](https://github.com/nyaosorg/go-readline-ny/blob/61b984c6759c67164c399dcf6bf066d2006db38c/readline.go#L17)

``` go
const (
        // CONTINUE is returned by key-functions to continue the line editor
        CONTINUE Result = iota
        // ENTER is returned by key-functions when Enter key is pressed
        ENTER Result = iota
        // ABORT is returned by key-functions when Ctrl-D is pressed with no command-line
        ABORT Result = iota
        // INTR is returned by key-functions when Ctrl-C is pressed
        INTR Result = iota
)
```

- `CONTINUE` は編集継続で、次のキー処理を行って問題ない時（普通はコレ）
- `ENTER` は Enter キーを押下したときのように入力内容を確定して、ReadLine の呼び出し元に帰らせてよいとき（ReadLine の error 戻り値は nil）
- `ABORT` は UNIX/Linux のシェルで何も入力していない状態で Ctrl-D キーを押下したときのように、一連の入力処理全体を終結させたいとき（ReadLine の error 戻り値は io.EOF）
- `INTR` は Ctrl-C キーを押下したときのように入力内容を破棄して、ReadLine の呼び出し元に帰らせたいとき（ReadLine の error 戻り値は readline.CtrlC）

実際のキーに割り当てる関数[^method2func] はこんな感じです。

[^method2func]: この関数は multiline.Editor のメソッドなので、そのままだと `func(context.Context,*readline.Buffer)` に代入することができないが、具体的なレシーバーとセットにして m.down という体裁にするとキャストなしに BindKeyClosure に与えることができる

[github.com/hymkor/go-multiline-ny/main.go](https://github.com/hymkor/go-multiline-ny/blob/e753dc4c1a7bf4d1ea2c8f87e9adf622f41d2370/main.go#L61)

```go
func (m *Editor) down(_ context.Context, _ *readline.Buffer) readline.Result {
	if m.csrline >= len(m.lines)-1 {
		return readline.CONTINUE
	}
	fmt.Fprintln(m.LineEditor.Out)
	m.after = func(line string) bool {
		m.updateLine(line)
		m.csrline++
		return true
	}
	return readline.ENTER
}
```

この関数自体は go-multiline-ny のもので、説明しだすと脱線が過ぎるのでほどほどにしますが、役割としては Ctrl-N もしくは ↓ キーがおされたとき（１）現在の編集行を確定し（２）編集が終わったあとに行う処理として編集行を次に移動させるということを設定しています（ただし、最終行の時はなにもしない）

+ `m.LineEditor` は readline.Editor のインスタンスへのポインタ
+ `m.LineEditor.Out` は `bufio.NewWriter( m.LineEditr.Writer )` 。コールバック関数から画面出力するときは通常これを使う（m.LineEditor.Writer を直接使うとタイミングがおかしくなる）
