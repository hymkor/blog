```header
Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2024/02/18/002652
Rem: App-Edited: 2024-02-19T13:36:34+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6801883189084047031
Rem: Published: 2024-02-18T13:05:22+09:00
Category: jujutsu
Updated: 2024-02-18T00:26:52+09:00
Title: その後 Jujutsu で分かったこと、失敗したことなど
```
+ [君のレポジトリを領域展開 - 次世代バージョン管理システム Jujutsu の世界](https://zenn.dev/zetamatta/books/c1e309aea68960)

2月3日の公開後も、ちまちま更新を入れてます。以下の体験とかも反映しています。

( でも、ページ構成に合わせたうまい挿入場所がなくて… 以下に関してはまとまったエピソードとして書いている本ブログの方が分かりやすいかも。Book の方は書く場所が分散してしまっているので )

#### A Git co-located repository （← よい日本語訳がない）

当初は、jj でタグが打てないのがネックになって移行できなかったんですが、[7章](https://zenn.dev/zetamatta/books/c1e309aea68960/viewer/07_git)に書いたとおり

+ 既存のローカルの Git レポジトリで、`jj git init --git-repo=.` で初期化

を行えば、Git と jj が共存状態のレポジトリ( [ a Git co-located repository](https://martinvonz.github.io/jj/v0.14.0/github/#working-in-a-git-co-located-repository) )となります。これで、ネイティブgitの方の`git tag` とか `git describe` が使えるようです。

そうすると何か問題やら制限があるのではないかと考えるべきですが

+ 普通はブランチを指しているはずの git の HEAD が、コミットを直接指すようになる  
    = カレントブランチがなくなるため、一部の git コマンドは発行できなくなる

といったところが確認できています。たとえば、GitHub よりコミットが進んだ状態で、`git push` を実行しようとすると

```
$ git push
fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push origin HEAD:<name-of-remote-branch>
```

というエラーになります。ただし、これは`jj branch track master@origin` を行えば、以後 `jj git push` が出来るので実害はありません。jj でコミットを進めると自動で git 側の HEAD も移動してもらえるようで、jj log をとると

```
$ jj log
@  uqpslxtp iyahaya@nifty.com 2024-02-18 12:43:20.000 +09:00 469c6103
│  (no description set)
◉  ysyyypoo iyahaya@nifty.com 2024-02-18 12:43:20.000 +09:00 HEAD@git 53b3435c
│  docs/release_note*.md: wrote about removing ezoe.lua
◉  ksuxxukq iyahaya@nifty.com 2024-02-18 12:40:37.000 +09:00 b9f43fa4
│  Remove nyagos.d\catalog\ezoe.lua (joke script)
◉  wsxquoxy iyahaya@nifty.com 2024-02-14 20:31:23.000 +09:00 master master@origin 69b80e1
2
```

と `HEAD@git` というマークで確認できます。

ネイティブな git が併用できるようになった結果、自分のタグ運用に問題がなくなりました。jj が普段使いできるようになったので、しばらく使い続けて、さらなる問題点などないか検証をつづけたいと思います。

#### バイナリの実行ファイルをコミットに入れてしまった

ちなみに、今まで出た一番まずい失敗は、Linux のバイナリの実行ファイルがうっかりコミットに入ったのに気付かずに `jj branch set -r @- master` → `jj git push` してしまったことです。

jj では `jj git push` したコミットは immutable なフラグがついて、編集不可能になってしまいます。つまり、ローカルレポジトリからも問題のコミットを消すことができなくなってしまいました。この immutable なフラグをオフにして、`git push -f` に相当する操作をしたかったのですが、その操作がよく分かりません。結局：

1. 別のディレクトリで `git clone`
2. そちらで `git reset @~`, `git push -f` し、問題のコミットを消す
3. 元のローカルレポジトリで、`jj git fetch` し、GitHub の変更を取り込む
4. immutable ではないコミットを `jj edit`, `jj restore` を繰り返して消す

とネイティブGit側の力技で逃げてしまいました。本当はどうすべきだったんでしょう。

こうなった一番の原因は Linux のバイナリをビルドした時に 3MB くらいになったのですが、この時 jj の「コミットに取り込めない」というエラーを

```
$ jj config set --repo snapshot.max-new-file-size 5MiB
```

で回避してしまったことです。ここはレポジトリに置けるファイルの上限を上げるのではなく、.gitignore に実行ファイル名を登録して、とりこむファイルの対象外にすべきでした。

これ、Windows だったら、共通 .gitignore に `*.exe` と設定しており、個別に実行する必要もなかったんですが、Linux だと実行ファイルは拡張子なしですから汎用的にマッチするパターンがないんですよね。個別に名前指定するのを厭ったのが失敗でした。

考えてみると、snapshot.max-new-file-size のデフォルト値が 1MB と低くおさえられている理由は、こういうバイナリファイルの誤コミットを防ぐためだったのかもしれません。さすがに、今は 1MiB に戻しています。
