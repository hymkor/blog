Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2024/06/13/133759
Rem: App-Edited: 2024-06-26T05:01:02+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6801883189113980829
Rem: Published: 2024-06-13T13:37:59+09:00
Category: lisp islisp
Updated: 2024-06-13T13:37:59+09:00
Title: Lisp で、メソッド名より前にレシーバー名をおいて、メソッドを呼び出す試み
---
+ (2024.06.26) 追記あり

Lisp でオブジェクト指向プログラミングをする場合、他の言語と違い、**(METHOD OBJECT PARAMS...)** みたいに呼び出すことが多い。

これを無理やり、**(OBJECT METHOD PARAMS...)** みたいに呼び出す方法を考えた。そのためには、

+ クラスは、そのクラスのメソッドの(名前 vs lambda) のリスト
+ `new` は、メソッドリストのクラスとパラメーターから、インスタンスを関数という体裁で作成する関数

とした。

`class-gmn.lsp`

```lisp
(defun new (klass :rest slot)
 (lambda (method-name :rest params)
  (let ((f (assoc method-name klass)))
   (if f
    (apply (cdr f) slot params)
    (format (error-output) "~s: method not found~%" method-name)))))

(defglobal integer-class
 (list
  (cons 'plus  (lambda (this other)
    (new integer-class (+ (car this) other))))
  (cons 'minus (lambda (this other)
    (new integer-class (- (car this) other))))
  (cons 'value (lambda (this)
    (car this)))))

(let ((obj (new integer-class 1)))
 (format (standard-output) "~s~%" (obj 'value))
 (format (standard-output) "~s~%" ((obj 'plus 2) 'value))
 (format (standard-output) "~s~%" ((obj 'minus 2) 'value)))
```

```
$ gmnlisp.exe class-gmn.lsp
1
3
-1
```

ただし、このコード、[gmnlisp](https://github.com/hymkor/gmnlisp) 以外、たとえば [OK! ISLisp](http://islisp.org/jp/download-jp.html) では次のようにエラーになってしまう。

```
$ ISLisp.exe
> ISLisp  Version 0.80 (1999/02/25)
>
ISLisp>(load "class-gmn.lsp")
> Error at FORMAT
> Undefined Function: OBJ
>>> ISLisp Debugger menu:
>>>            1    return to toplevel.
>>>           :h    show debugger command help.
Error:1>1
ISLisp>(quit)
```

変数と関数で名前空間がわかれているためだ。funcall を使えば、他の処理系(islisp.exe) でも動くようになる。

`class.lsp`

```lisp
(defun new (klass :rest slot)
 (lambda (method-name :rest params)
  (let ((f (assoc method-name klass)))
   (if f
    (apply (cdr f) slot params)
    (format (error-output) "~s: method not found~%" method-name)))))

(defglobal integer-class
 (list
  (cons 'plus  (lambda (this other)
    (new integer-class (+ (car this) other))))
  (cons 'minus (lambda (this other)
    (new integer-class (- (car this) other))))
  (cons 'value (lambda (this)
    (car this)))))

(let ((obj (new integer-class 1)))
 (format (standard-output) "~s~%" (funcall obj 'value))
 (format (standard-output) "~s~%" (funcall (funcall obj 'plus 2) 'value))
 (format (standard-output) "~s~%" (funcall (funcall obj 'minus 2) 'value)))
```

```
$ ISLisp.exe
> ISLisp  Version 0.80 (1999/02/25)
>
ISLisp>(load "class.lsp")
1
3
-1
T
ISLisp>(quit)
```

うーん、動くようにはなったけど… あんまりかっこよくない形になってしまった。

### (2024.06.26) 追記

class-gmn.lsp がISLisp.exe で動かないのに、gmnlisp では動くのは、gmnlisp が関数と関数への参照を区別しないのが原因だった。これはISLispの規格としては許容される範囲のはずだが、gmnlisp でテストして動いたコードが ISLisp で動かないという状況はあまりよくないと考えた。

そのため、最新版では `(funcall)` で deference しないと

```
$ gmnlisp.exe class-gmn.lsp
obj: expected function
        at format
        at let
$
```

ときちんとエラーにするようにした。一方、ISLisp でもエラーにならない class.lsp は変わらず動作可能になっている。

```
$ gmnlisp.exe class.lsp
1
3
-1
```
