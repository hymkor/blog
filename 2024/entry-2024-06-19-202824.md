```header
Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2024/06/19/202824
Rem: App-Edited: 2024-06-20T12:05:46+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6801883189115562436
Rem: Published: 2024-06-19T20:28:24+09:00
Category: Lisp ISLisp
Updated: 2024-06-19T20:28:24+09:00
Title: ISLisp の包括関数のどれが呼ばれるだろう
```
ISLisp の包括関数 (generic function) って、要は「関数の多重定義」みたいなもんだと思うんだが、一つ疑問があった。

+ `(defgeneric)` で宣言したパラメーターリストと、`(defmethod)` で宣言した関数群で、引数名がくいちがっていても大丈夫だろうか？

実験してみよう[^1]

[^1]: まぁ、規格書を読めばいいわけですが、やっぱり入門書というわけじゃないので、小難しくて読みづらいんですよ。

**generic.lsp** :

```
; これは、とりあえず期待どおり動くかどうかのチェック
(defgeneric foo (a b))
(defmethod foo ((a <integer>) (b <string>))
  (format (standard-output) "foo method-1 a=[~S] b=[~S]~%" a b))
(defmethod foo ((b <float>) (a <string>))
  (format (standard-output) "foo method-2 b=[~S] a=[~S]~%" b a))

(foo 1 "a")
(foo 1.0 "b")

; 名前と順番がくいちがう時、どちらが優先されるか？
(defgeneric bar (a b))
(defmethod bar ((a <integer>) (b <string>))
  (format (standard-output) "bar method-1 a=[~S] b=[~S]~%" a b))
(defmethod bar ((b <float>) (a <string>))
  (format (standard-output) "bar method-2 b=[~S] a=[~S]~%" b a))
(defmethod bar ((b <string>) (a <float>))
  (format (standard-output) "bar method-3 a=[~S] b=[~S]~%" b a))

(bar 1 "a")
(bar 1.0 "b")

; やはり、全部一致しているものが優先して呼ばれるのか？
(defgeneric gar (a b))
(defmethod gar ((a <integer>) (b <string>))
  (format (standard-output) "gar method-1 a=[~S] b=[~S]~%" a b))
(defmethod gar ((b <float>) (a <string>))
  (format (standard-output) "gar method-2 b=[~S] a=[~S]~%" b a))
(defmethod gar ((b <string>) (a <float>))
  (format (standard-output) "gar method-3 b=[~S] a=[~S]~%" b a))
(defmethod gar ((a <float>) (b <string>))
  (format (standard-output) "gar method-4 a=[~S] b=[~S]~%" a b))

(gar 1 "a")
(gar 1.0 "b")
```

### まず、[OK!ISLisp](http://islisp.org/OKIISLisp.html)

```
$ ISLisp.exe
> ISLisp  Version 0.80 (1999/02/25)
>
ISLisp>(load "generic.lsp")
foo method-1 a=[1] b=["a"]
foo method-2 b=[1.0] a=["b"]
bar method-1 a=[1] b=["a"]
bar method-2 b=[1.0] a=["b"]
gar method-1 a=[1] b=["a"]
gar method-4 a=[1.0] b=["b"]
T
ISLisp>
```

+ gar の結果から：仮引数の名前と順番両方が一致されるメソッドが最優先に呼ばれる
+ bar の結果から：順番が一致しているメソッドの方が、名前が一致しているメソッドより優先される
+ (引用していないが) 引数が一致するのものがなければ、エラーになる模様

### [IRIS](https://github.com/islisp-dev/iris) の場合

スクリプトを読み込む方法がわからなかったので、リダイレクトで流し込んだ。

```
$ go install github.com/islisp-dev/iris@latest

$ iris < generic.lsp
Iris ISLisp Interpreter Commit HEAD on go1.22.3
Copyright 2017 islisp-dev All Rights Reserved.
>>> FOO
>>> FOO
>>> FOO
>>> foo method-1 a=[1] b=["a"]
NIL
>>> foo method-2 b=[1] a=["b"]
NIL
>>> BAR
>>> BAR
>>> BAR
>>> BAR
>>> bar method-1 a=[1] b=["a"]
NIL
>>> bar method-2 b=[1] a=["b"]
NIL
>>> GAR
>>> GAR
>>> GAR
>>> GAR
>>> GAR
>>> gar method-1 a=[1] b=["a"]
NIL
>>> gar method-4 a=[1] b=["b"]
NIL
```

OK!ISLisp と同様に呼ばれている。

(OK!ISLisp と違って、`~s` をS式で表示する書式とみなしてくれないという違いがあった。ちゃんと英大文字で `~S` と書かなくてはいけないようだ)

### [Easy-ISLisp (eisl)](https://github.com/sasagawa888/eisl)

Windows はサポートしておらず、バイナリの実行ファイルも配布されていないようなので、wsl でビルドした。

```
$ git clone https://github.com/sasagawa888/eisl
$ cd eisl
$ sudo apt install libncurses-dev
$ make
```

```
hymkor@DESKTOP-NPOTG52:/mnt/c/Users/hymkor/src/eisl$ ./eisl -s ./generic.lsp
foo method-1 a=[1] b=[\"a\"]
foo method-2 b=[1.0] a=[\"b\"]
bar method-1 a=[1] b=[\"a\"]
bar method-2 b=[1.0] a=[\"b\"]
gar method-1 a=[1] b=[\"a\"]
gar method-4 a=[1.0] b=[\"b\"]
```

OK!ISLisp や IRIS と同じ結果になった。
( 二重引用符の扱いがちょっと違うが )

---

最後に、正確な引数の一致ではなく、単に宣言の後勝ちになっている可能性があるので、宣言の順番を入れ変えてみた。

**generic2.lsp**

```
(defgeneric gar (a b))
(defmethod gar ((a <integer>) (b <string>))
  (format (standard-output) "gar method-1 a=[~S] b=[~S]~%" a b))
(defmethod gar ((a <float>) (b <string>))
  (format (standard-output) "gar method-4 a=[~S] b=[~S]~%" a b))
(defmethod gar ((b <float>) (a <string>))
  (format (standard-output) "gar method-2 b=[~S] a=[~S]~%" b a))
(defmethod gar ((b <string>) (a <float>))
  (format (standard-output) "gar method-3 b=[~S] a=[~S]~%" b a))

(gar 1 "a")
(gar 1.0 "b")
```

```
$ ISLisp.exe
> ISLisp  Version 0.80 (1999/02/25)
>
ISLisp>(load "generic2.lsp")
gar method-1 a=[1] b=["a"]
gar method-2 b=[1.0] a=["b"]
T
ISLisp>
```

method-4 と method-2 は、ともに float, string という引数だが、仮引数名も一致していていなければならないのであれば、 method-4 の方が呼ばれるはずだが、method-2 の方が呼ばれている。

つまり、

+ あくまで型の順番を見ているだけで、仮引数名は照合されていない
+ 同じ仕様の関数を定義すると、あとのもので上書きされる

ということか
