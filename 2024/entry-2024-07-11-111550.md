Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2024/07/11/111550
Rem: App-Edited: 2024-07-11T11:17:53+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6801883189121049566
Rem: Published: 2024-07-11T11:15:50+09:00
Category: Go
Updated: 2024-07-11T11:15:50+09:00
Title: Go の "flag" パッケージのヘルプ表示部分を差し替える
---
flag パッケージのヘルプ表示は `-h` オプションを指定された時や、引数ゼロの時に自動で表示される。

だが、issue 対応している中、その自由度が結構きつくて、ユーザの提案に対応できない事態が発生した。

```
-flagname XXXXX
    UUUUUUUUUUUU (default: DDDDD)
```

+ この時 XXXXX の内容は独立した引数で与えるのではなく、UUUUUUUUUUUU の中に ``` `XXXXX` ``` といった形で含んでいなくてはいけない。存在しなかった場合、型名になる 
    + XXXXX が単語ではなく、[always|auto|never] といった選択肢を書きたい場合,同じフレーズが二回ヘルプに表示されてしまうのは不都合
+ デフォルト値がゼロ値の時、`(default: DDDDD)` が表示されない
    + デフォルト値の表示はユーザに任せた方がいいんじゃね？
+ 廃止オプションなど、Usage として表示させたくない場合に対応できない

必ずしも提案を採用する必要はなかったけれども、廃止オプションに関しては `(obsolute)` とか表示して回避するのはみっともないなーと思ったので、ヘルプ表示をさしかえることにした。

+ 改造点
    + flag.String や flag.Bool のusage引数で引数の名前として解釈する部分は ``` `name` ``` ではなく、`name\vusage` とする。name は本文では表示しない
    + usage引数が "" の時は、ヘルプに表示しない

```
var (
    flagOneLineScript = flag.String("e", "", "code\vexecute code")
    flagColor         = flag.String("color", "always", "[always|never] (default: always)\vcolorize the output")
    flagCompile       = flag.String("compile", "", "executable-name\vcompile executable with <script>.lua embedded; script is not executed")
    flagDebug         = flag.Bool("D", false, "print debug information")
    _                 = flag.Bool("nologo", false, "")
)

func main(){
    ; 略
    flag.Usage = newUsage
    flag.Parse()
    ; 略
}

func newUsage() {
    // 見出しを表示する
    w := flag.CommandLine.Output()
    fmt.Fprintf(w, "Expect-lua %s-windows-%s with %s\n",
        version, runtime.GOARCH, runtime.Version())
    fmt.Fprintf(w, "Usage of %s:\n", os.Args[0])

    // 各オプションの説明を出す
    newPrintDefaults(flag.CommandLine)
}

func newPrintDefaults(fs *flag.FlagSet) {
    fs.VisitAll(func(f *flag.Flag) {
        // 各フラグの内容が f で与えられるので、
        // 出したい内容を io.Writer の fs.Output に出力する
        if f.Usage == "" {
            return // for obsolute flag
        }
        var b strings.Builder

        fmt.Fprintf(&b, "  -%s", f.Name)

        var detail string
        var usage string
        var ok bool

        if detail, usage, ok = strings.Cut(f.Usage, "\v"); ok {
            fmt.Fprintf(&b, " %s", detail)
        } else {
            usage = f.Usage
        }
        if b.Len() <= 4 {
            b.WriteByte('\t')
        } else {
            b.WriteString("\n    \t")
        }
        b.WriteString(strings.ReplaceAll(usage, "\n", "\n    \t"))
        fmt.Fprintln(fs.Output(), b.String())
    })
}
```

```
$ .\expect.exe
Expect-lua v0.12.0-14-g5641909-windows-amd64 with go1.20.14
Usage of .\expect.exe:
  -D    print debug information
  -color [always|never] (default: always)
        colorize the output
  -compile executable-name
        compile executable with <script>.lua embedded; script is not executed
  -e code
        execute code

```

よし！
