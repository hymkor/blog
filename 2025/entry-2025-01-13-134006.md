Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2025/01/13/134006
Rem: App-Edited: 2025-01-13T14:07:36+09:00
Rem: Draft: no
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6802418398319717273
Rem: Published: 2025-01-13T14:07:36+09:00
Category: go readline go
Updated: 2025-01-13T13:40:06+09:00
Title: go-readline-ny 1.7.0 の新しいシンタックスハイライティング
---
+ [Release v1.7.0 · nyaosorg/go-readline-ny](https://github.com/nyaosorg/go-readline-ny/releases/tag/v1.7.0)

以前は次のような interface の実装を作らないといけなかったので、たいへんだった。nyagos にしても sqlbless にしても、色を指定するためだけに１ソースファイル費していた。各文字に対する色を指定する `Coloring` 型だけでなく、色を表現する `ColorSequence` も意味不明だったのではなかっただろうか。

```go
type Coloring interface {
    // Reset has to initialize receiver's fields and return default color.
    Init() ColorSequence
    // Next has to return color for the given rune.
    Next(rune) ColorSequence
}
```

新しい方式では、ハイライトを適用する範囲を正規表現、色指定をエスケープシーケンスそのもので指定するようにしたので、非常に直感的になったはず。しかも数行で済む。

```go
editor := &readline.Editor{
    // :
    Highlight: []readline.Highlight{
        {Pattern: regexp.MustCompile("&"), Sequence: "\x1B[33;49;22m"},
        {Pattern: regexp.MustCompile(`"[^"]*"`), Sequence: "\x1B[35;49;22m"},
        {Pattern: regexp.MustCompile(`%[^%]*%`), Sequence: "\x1B[36;49;1m"},
        {Pattern: regexp.MustCompile("\u3000"), Sequence: "\x1B[37;41;22m"},
    },
    ResetColor:     "\x1B[0m",
    DefaultColor:   "\x1B[33;49;1m",
}
```

例では正規表現を使っているが、これ `interface{ FindAllStringIndex(string, int) [][]int }}` を満たす型であれば何でもよいので、ユーザ独自の指定もできる。

SQL-Bless などでは次のように SQL の予約語を指定するのに、`ReservedWordPattern` 型を作ったりした。

```go
type ReservedWordPattern map[string]struct{}

var rxWords = regexp.MustCompile(`\b\w+\b`)

func (h ReservedWordPattern) FindAllStringIndex(s string, n int) [][]int {
    // 引用注：まずあらゆる単語を列挙してから、登録されていない単語をリストから削除するようにしている。
    // "slices" パッケージを使っていないのは、古い Go でも動かせるようにするため
    matches := rxWords.FindAllStringIndex(s, n)
    for i := len(matches) - 1; i >= 0; i-- {
        word := s[matches[i][0]:matches[i][1]]
        if _, ok := h[strings.ToUpper(word)]; !ok {
            copy(matches[i:], matches[i+1:])
            matches = matches[:len(matches)-1]
        }
    }
    return matches
}

func newReservedWordPattern(list ...string) ReservedWordPattern {
    m := ReservedWordPattern{}
    for _, word := range list {
        m[strings.ToUpper(word)] = struct{}{}
    }
    return m
}

// :
    var editor multiline.Editor

    editor.LineEditor.ResetColor = "\x1B[0m"
    editor.LineEditor.DefaultColor = "\x1B[39;49;1m"
    editor.LineEditor.Highlight = []readline.Highlight{
        {Pattern: newReservedWordPattern("ALTER", "COMMIT", "CREATE", "DELETE", "DESC", "DROP", "EXIT", "HISTORY", "INSERT", "QUIT", "REM", "ROLLBACK", "SELECT", "SPOOL", "START", "TRUNCATE", "UPDATE", "AND", "FROM", "INTO", "OR", "WHERE"), Sequence: "\x1B[36;49;1m"},
        {Pattern: regexp.MustCompile(`[0-9]+`), Sequence: "\x1B[35;49;1m"},
        {Pattern: regexp.MustCompile(`"[^"]*"|"[^"]*$`), Sequence: "\x1B[31;49;1m"},
        {Pattern: regexp.MustCompile(`'[^']*'|'[^']*$`), Sequence: "\x1B[35;49;1m"},
    }
```

さて、はたして、これは使ってもらえたもんだか…
（いうて、go-readline-ny のユーザ自体もたぶん 2,3人しかいないはずではあるが）

### 楽屋裏

（別に完全に理解する必要はなく、雰囲気で読んでね）

シンタックスハイライトは入力された各文字ごとに色を管理するので、色の表現する表現コストが大きいとたいへんなことになる。エスケープシーケンスの文字列をそのま使うと、ヒープ確保回数・比較回数が文字数に比例する。

当初導入した `ColorSequence` は `"\x1B[31;49;1m"` といったエスケープシーケンスを 31,49,1 という8bit の数字列とし、それを bit 的に連結して32bit整数にしていた。だが、連結コストも意外と大きいし、ぱっと見分かりづらい。

そして、各文字ごとに指定する interface である Coloring も実装がたいへんで、二重引用符で囲まれた文字列の色付け程度なら簡単だが、最後の文字まで読まないと判断がつかないような予約語の色を変えるようなケースに対応できない。

こういう時は、他の実装を見るのがよい。ということで、vim の `syntax/*.vim` を見てみた。

**wifky.vim** （昔、[自作 WikiEngine](http://wifky.nyaos.org/) 用に自分が作った設定ファイルらしい。まったく覚えていなかった）
```
highlight wifkyStrong term=bold cterm=bold cterm=bold
highlight wifkyEm term=italic ctermfg=4
highlight wifkyAttachment  term=standout ctermfg=2
highlight wifkyPre  ctermfg=1
highlight wifkyQuote term=italic ctermfg=3

syntax region wifkyPre start=/^8</   end=/>8$/
syntax region wifkyPre start=/```/  end=/```/
syntax match  wifkyStrong /^<<.*>>$/
syntax match  wifkyStrong /^!.*$/
syntax region wifkyEm  start=/'''*/   end=/'''*/
syntax region wifkyEm  start=/^>>/ end=/<<$/
syntax match  wifkyEm /^[ \t]*[:\*+]\+/
syntax match  wifkyAttachment /<<{[^}]*}\({[^}]*}\)\?/
syntax region Function   start=/((/   end=/))/
syntax region Underlined start=/\[\[/ end=/\]\]/
syntax region Underlined start=/>>{/  end=/}/   skip=/}{/
syntax region Underlined start=/http:\/\/[^{ \n][^{ ]*{/ end="}"
syntax match  Underlined /\[[^\]]*|http:\/\/[^\]]*\]/
syntax match  wifkyQuote /^"".*$/
" vim:set notextmode:
```

なるほど、色の付け方を `highlight` 文で、それを付ける範囲を `syntax` 文で指定するという方式を使うわけか。

ということで、これを真似て `readline.Highlight` 型を作ってみた。範囲については当初 vim と同様に開始位置と終了位置を指定していたが、一行しか編集しない readline なら`.*`でつないで全体を指定させたらいいじゃないかと判断した。

( go-multiline-ny だと複数行を編集できるのだが、go-readline-ny が複数行を想定した設計にするのはスコープ的におかしいので、そういう余計な配慮はしないと決めていた。なお、新ハイライト機能自体は go-multiline-ny でも(行をまたげない点を除けば) ちゃんと機能する )

### 互換性維持

（ここも別に完全に理解する必要はなく、雰囲気で読んでね）

旧ハイライトインターフェイスではるところの、Coloring はまだサポートしている( 近い将来には廃止予定だが )

だが、最初は `Coloring` / `ColorSequence` 機能へのラッパーのような形で Highlight を実装していた。最終的には

```go
type Highlight struct {
    Pattern  interface{ FindAllStringIndex(string, int) [][]int }
    Sequence string
}
```

という形に落ちついているが、当初は `Sequence` フィールド は `string` ではなく `ColorSequence` 型で、`Highlight` 型も `Init` メソッド・`Next` メソッドを実装した `Coloring` の実装だった。

これを逆転させるために、新方式・旧方式の両方の色表現を両方取り扱うための共通インターフェイスとして

```go
var ci interface { // 引用注：Coloring の共通化用
    Init() colorInterface
    Next(rune) colorInterface
}

type colorInterface interface { // 引用注：ColorSequnce の共通化用
    io.WriterTo
    Equals(colorInterface) bool
}
```

というものを用意した。`ColorSequence` は元々 `io.WriterTo` を実装していたので、`Equals` を追加実装すればよい。新仕様では表向き string を使っているが、内部的には `escapeSequenceId` というID型に変換させ、これに同メソッドを実装した。

`Coloring` も、そのままだと `ColorSequence` を直接扱っていて、共通化させられない。ここは簡単なブリッジを用意した。

```go
type colorBridge struct {
    base Coloring
}

func (c *colorBridge) Init() colorInterface {
    return c.base.Init()
}

func (c *colorBridge) Next(r rune) colorInterface {
    return c.base.Next(r)
}
```

こうして互換性をなんとか維持した結果、nyagos も SQL-Bless も、ともに go get -u しても特にコンパイルエラーは発生せず、色自体は従来どおり表示できていることを確認している。

だが、旧ハイライティングは使っているユーザは自分意外ほぼいない。ここまでして互換性を維持する意味はなかったのでないだろうか。nyagos も SQL-Bless もどっちにしても新仕様向けに直すわけだし。

自分の結論としては、開発中の過渡期においても一応フル動作ができるというのは動作確認が非常にやりやすいというメリットがあったと考えている。大改造で一番きついのは、動作確認ができない時間が長くなると「この修正ははたして正しい修正なのか？」が分からないままコーディングを進めないといけないことだ。設計ミスが致命的だった時、開発モチベーションが一気に下がってしまう。この不安感は非常にやばい。それがあまりなかったため、この改造はとても楽しかった。

この新旧まざったコードのうち、いずれ旧コードは削除することになる。ソースからは消えるけど、git の過去履歴としてはきっちり残るので、あまり惜しいという気持ちはない。よい体験だった。

### LSP

Language Server Protocol とかも視野には入れないといけないとは思うわけだが、その前の syntax highlighting が今の有様では…というところから、v1.7.0 の修正が始った。

まぁ、予約語を得る仕組みさえわかれば、補完の仕組み、色付けの仕組みはもうあるわけなので、後は勉強だけかなと…甘いかな？
