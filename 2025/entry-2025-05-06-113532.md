```header
Rem: Alternate-Url: https://zetamatta.hatenablog.com/entry/2025/05/06/113532
Rem: App-Edited: 2025-05-19T15:05:23+09:00
Rem: Draft: yes
Rem: Url-To-Edit: https://blog.hatena.ne.jp/zetamatta/zetamatta.hatenablog.com/atom/entry/6802418398411424437
Rem: Published: 2025-05-06T11:35:32+09:00
Category: Lisp c-gpt
Updated: 2025-05-06T11:35:32+09:00
Title: ISLisp の規格に関する問題点まとめ by ChatGPT
```
どこまで本当かは保証しかねるところですが、ちょっと同意できるところも多いです。

### 1. **シンボルの大小文字に関する仕様の複雑さ**

* ISLisp ではシンボルの識別において **英大文字・小文字の区別をしない**。
* しかし、シンボルを表示する際には **英大文字で表示することが期待されている**。
* さらに、`convert` などでシンボルを文字列化する場合には、**最初に作成されたオリジナルの文字列を復元**する必要がある。
  * 例: `'a` も `'A` も同じシンボルとして扱われるが、表示や文字列変換時に異なる扱いが期待されることがある。
* この挙動は **実装が非常に困難で、メモリ使用量も増加**する上に、実用上のメリットが乏しい。

### 2. **予約語（Reserved Symbols）の定義が曖昧**

* JIS 規格においては `&rest` や `:rest` などの引数キーワードを「予約語」として明示している（狭義の予約語）。
* 一方、処理系の実装では、再定義を禁止すべき特殊形式名や定数名（例: `if`, `*pi*`）も便宜上「予約語（広義）」として扱う必要がある。
  * この「広義の予約語」は仕様上明示されておらず、**実装者の判断に委ねられている**ため、挙動の差異が生じやすい。

### 3. **`convert` の動作仕様が細かく厳密**

* たとえば `(convert #\a <general-vector>)` のような変換は、「エラーを発生させること」と規定されている。
* 他の言語では許容される柔軟な型変換が、**ISLisp では明確に禁止されているケースが多い**。
  * これにより、**柔軟性を欠き、使い勝手が悪い印象**を与えやすい。

### 4. **標準規格における実用性への配慮の乏しさ**

* 仕様に準拠しようとすると、**開発・実装の手間が極めて大きくなる一方で、実用上の恩恵がほとんどない**。
* 特に OSS として処理系を開発・維持する立場からは、**コストに見合ったメリットが感じられない**。

---

僕が個人的に感じるところでは

- ISLisp のクラスは minimal な仕様がよく見えず、いきなり巨大な仕様を完成しないと部分のテストもできない

というところが最悪で、これもあって未だクラス部分が完成できていません。結構いいところまではいけてるんですがねぇ…（ISLisp の検証プログラムによるテスト結果：OK = 11532, NG = 4879）
